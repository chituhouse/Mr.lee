const { execSync } = require('child_process');
const fs = require('fs');
const path = require('path');

const SITES_DIR = '/home/jarvis/sites';
const NGINX_SITES = '/etc/nginx/sites-available';
const NGINX_ENABLED = '/etc/nginx/sites-enabled';
const SSL_CERT = '/etc/letsencrypt/live/mistprism.com-0001/fullchain.pem';
const SSL_KEY = '/etc/letsencrypt/live/mistprism.com-0001/privkey.pem';

class Deployer {
  constructor() {
    this.domain = process.env.TASK_DOMAIN;
    if (!this.domain) {
      console.warn('[Deployer] TASK_DOMAIN not set, deployment disabled');
    }
  }

  /**
   * 部署任务到子域名
   * @param {{ taskId, outputDir, type, entry }} task
   * @returns {{ url, subdomain }}
   */
  async deploy(task) {
    if (!this.domain) {
      throw new Error('TASK_DOMAIN not configured');
    }

    const subdomain = `t-${task.taskId}`;
    const fqdn = `${subdomain}.${this.domain}`;
    const siteDir = path.join(SITES_DIR, subdomain);

    // 复制文件到站点目录
    fs.mkdirSync(siteDir, { recursive: true });
    execSync(`cp -r ${task.outputDir}/* ${siteDir}/`);
    console.log(`[Deployer] Files copied to ${siteDir}`);

    if (task.type === 'node') {
      await this._deployNode(task, subdomain, fqdn, siteDir);
    } else {
      await this._deployStatic(subdomain, fqdn, siteDir);
    }

    const url = `https://${fqdn}`;
    console.log(`[Deployer] Deployed: ${url}`);
    return { url, subdomain };
  }

  async _deployStatic(subdomain, fqdn, siteDir) {
    const conf = `# Auto-generated by deployer.js
server {
    listen 80;
    server_name ${fqdn};
    return 301 https://\\$host\\$request_uri;
}

server {
    listen 443 ssl;
    server_name ${fqdn};

    ssl_certificate ${SSL_CERT};
    ssl_certificate_key ${SSL_KEY};

    root ${siteDir};
    index index.html;

    location / {
        try_files \\$uri \\$uri/ =404;
    }
}
`;
    this._writeNginxConf(subdomain, conf);
  }

  async _deployNode(task, subdomain, fqdn, siteDir) {
    // 安装依赖
    const pkgPath = path.join(siteDir, 'package.json');
    if (fs.existsSync(pkgPath)) {
      console.log('[Deployer] Installing dependencies...');
      execSync('npm install --production', { cwd: siteDir, timeout: 60000 });
    }

    // 用 pm2 启动
    const port = this._allocatePort(subdomain);
    const entry = task.entry || 'server.js';
    const appName = `task-${subdomain}`;

    // 停止旧实例（如果存在）
    try {
      execSync(`pm2 delete ${appName}`, { stdio: 'ignore' });
    } catch (_) { /* ignore */ }

    execSync(
      `pm2 start ${entry} --name ${appName} --cwd ${siteDir} -- --port ${port}`,
      { env: { ...process.env, PORT: String(port) } }
    );
    console.log(`[Deployer] pm2 started ${appName} on port ${port}`);

    // Nginx 反向代理
    const conf = `# Auto-generated by deployer.js
server {
    listen 80;
    server_name ${fqdn};
    return 301 https://\\$host\\$request_uri;
}

server {
    listen 443 ssl;
    server_name ${fqdn};

    ssl_certificate ${SSL_CERT};
    ssl_certificate_key ${SSL_KEY};

    location / {
        proxy_pass http://127.0.0.1:${port};
        proxy_set_header Host \\$host;
        proxy_set_header X-Real-IP \\$remote_addr;
        proxy_set_header X-Forwarded-For \\$proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto \\$scheme;
    }
}
`;
    this._writeNginxConf(subdomain, conf);
  }

  _writeNginxConf(subdomain, conf) {
    // 先写到 sites 目录（jarvis 有权限），再 cp 到 nginx
    const tmpPath = path.join(SITES_DIR, `${subdomain}.conf`);
    const confPath = path.join(NGINX_SITES, `task-${subdomain}`);
    fs.writeFileSync(tmpPath, conf);
    execSync(`sudo cp ${tmpPath} ${confPath}`);

    // 启用站点 + 测试 + 重载
    execSync(`sudo /bin/ln -sf ${confPath} ${NGINX_ENABLED}/task-${subdomain}`);
    execSync('sudo /usr/sbin/nginx -t');
    execSync('sudo /usr/sbin/nginx -s reload');
    console.log(`[Deployer] Nginx configured for ${subdomain}`);
  }

  _allocatePort(subdomain) {
    // 基于子域名哈希分配端口（范围 10000-19999）
    let hash = 0;
    for (const ch of subdomain) {
      hash = ((hash << 5) - hash + ch.charCodeAt(0)) | 0;
    }
    return 10000 + (Math.abs(hash) % 10000);
  }
}

module.exports = { Deployer };
